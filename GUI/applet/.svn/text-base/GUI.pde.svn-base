import Jama.*;
import javax.media.opengl.*;
import processing.opengl.*;
import java.nio.FloatBuffer;
import java.util.ArrayList;
import oscP5.*;
import controlP5.*;
import picking.*;

ControlP5 controlP5;
DropdownList ruleChoiceList;
GL gl;
//Picker camPicker, charPicker;
Picker picker;
color bGround = color(70,70,70);
int prevID;
ArrayList<Cam> cameras = new ArrayList<Cam>(); // List of Cameras
ArrayList<Character> characters = new ArrayList<Character>(); // List of Characters
OscP5 oscP5;
int port = 8888;
NetAddress interfaceAddr;
String[] lines;
int selectedRule;
void setup() {
  size(900, 600, OPENGL);
  background(bGround);
  
//  pushMatrix();
//  rotateX(HALF_PI);
  controlP5 = new ControlP5(this);
  ruleChoiceList = controlP5.addDropdownList("ruleChoiceList",850,100,100,100);
  customize(ruleChoiceList);
  selectedRule = 0;
//  popMatrix();
  gl = ((PGraphicsOpenGL)g).gl;

//  camPicker = new Picker(this);
//  charPicker = new Picker(this);
  picker = new Picker(this);
  oscP5 = new OscP5(this, port);
  // TODO(sanjeet): Change the address
  interfaceAddr = new NetAddress("127.0.0.1", port);
  
  noStroke();
  lines = loadStrings("fileFriedrich.txt"); // Hardcoded input file name
  String[] tokens = split(lines[0], " ");
  if (tokens.length != 1) {
    println("Incorrect file format for number of cameras");
    return;
  }
  int numOfCams = int(tokens[0]);
  for (int i=1; i<numOfCams+1; i++) {
    
    tokens = split(lines[i], " ");
    float[] matrix = new float[16];
    for (int j=0; j<tokens.length; j++) {
      matrix[j] = float(tokens[j]);
    }
    
    cameras.add(new Cam(FloatBuffer.wrap(matrix))); // add all the cameras
    
  }
  
  tokens = split(lines[1 + numOfCams], " ");
  if (tokens.length != 1) {
    println("Incorrect file format for number of characters");
    return;
  }
  int numOfChars = int(tokens[0]);
  for (int i= 2 + numOfCams; i<lines.length; i++) {
    tokens = split(lines[i], " ");
    float[] matrix = new float[16];
    for (int j=0; j<tokens.length; j++) {
      matrix[j] = float(tokens[j]);
    }
    
    characters.add(new Character(FloatBuffer.wrap(matrix))); // add all the characters
  } 
}

void draw() { // display things

resetMatrix();
//beginCamera();
camera();
rotateX(HALF_PI);
/* rotation using a and d
PMatrix3D foRealCameraMatrix=new PMatrix3D();
getMatrix(foRealCameraMatrix);
*/
//translate(0,-100, -400 );
//translate(0,0, 0 );
//rotate(sin(millis() * 0.001), 1,0,0);

background(bGround);

for (int i=0; i<cameras.size(); i++) {
//    camPicker.start(i);  //add picker to each cam
    picker.start(i);
    cameras.get(i).display();
  }
//  camPicker.stop();
    
  
  
for (int i=cameras.size(); i<cameras.size()+characters.size(); i++) {
//    charPicker.start(i);
    picker.start(i);
    characters.get(i-cameras.size()).display();
//    println(i + " " + characters.get(i).g
  }
//  charPicker.stop();
  picker.stop();
  
  
//endCamera();
  
//  int id = camPicker.get(mouseX, mouseY);
//  if (id > -1) {
//    for (int i=0; i<cameras.size(); i++) {
//      if (i == id) {
//        cameras.get(id).changeToSelectedColor();
//        cameras.get(id).isSelected = true;
//      } else {
//        cameras.get(i).setDefaultColor();
//        cameras.get(i).isSelected = false;        
//      }
//    }
//  }

  //checks for rule violations
  int id = -1;
  for(int i = 0; i<cameras.size(); i++){
    if(cameras.get(i).isSelected){
      if(selectedRule==0)
        RulesChecker.checkLineOfAction(cameras, characters, i);
      else if (selectedRule == 1)
        RulesChecker.checkThirtyDegreeRule(cameras, characters, i);
      else
        resetAllCams();
      
    }
  }
  
  /* This is for camera rotation using a and d
  resetMatrix();
  pushMatrix();
  setMatrix(myCamera);
  rotate(angle);
  getMatrix();
  popMatrix;
  */
  
  //have to rotate back to original orientation in order to properly display the drop-down menu
  rotateX(PI);
  rotateX(HALF_PI);
  controlP5.draw();

}

//used for debugging
void resetAllCams(){
  for(int i = 0; i<cameras.size(); i++){
    cameras.get(i).setDefaultColor();
  }
}

void mouseClicked() {
  
//  int id = camPicker.get(mouseX, mouseY);
  int id = picker.get(mouseX, mouseY);
  if (id > -1) {
    for (int i=0; i<cameras.size(); i++) {
      if (i == id) {
        cameras.get(id).changeToSelectedColor();
        cameras.get(id).isSelected = true;
      } else {
        cameras.get(i).setDefaultColor();
        cameras.get(i).isSelected = false;      
      }
    }
    
    
    //RulesChecker.checkLineOfAction(cameras, characters, id);
    
  }
}

void mouseDragged(){
  
//  int id = camPicker.get(mouseX, mouseY);
  int id = picker.get(mouseX, mouseY);
  /*
  //keep objects from being selected while dragging other objects; DOESN'T FIX ANYTHING YET
  if(id > -1 && id == prevID){
//    cameras.get(id).changeToDragColor();
    println("indragged same");
    cameras.get(id).drag(mouseX, mouseY);
  }
  */
  if (id > -1) {
    for (int i=0; i<cameras.size(); i++) {
      if (i == id) {
//        println("indragged diff " + " x is " + mouseX + " y is " + mouseY);
        //cameras.get(id).changeToDragColor();
        cameras.get(id).drag(mouseX, mouseY);
        prevID = id;
        break;
      }
    }
    
//    int id = camPicker.get(mouseX, mouseY);

      for (int i=cameras.size(); i<cameras.size()+characters.size(); i++) {
        println(i + " hi " + " camSize is " + cameras.size() + " charSize is" + characters.size() + " both together are " + cameras.size() + characters.size());
        if (i == id) {
//          characters.get(id).changeToDragColor();
          
          characters.get(id - cameras.size()).drag(mouseX, mouseY);
          println("char is " + id);
          break;
          
        }
      }
  }
  
  
}

/*
void mouseReleased(){
  int id = camPicker.get(mouseX, mouseY);
  if (id > -1) {
    for (int i=0; i<cameras.size(); i++) {
      if (i == id) {
        cameras.get(id).changeToDefaultColor();
      }
    }
  }
  
  id = charPicker.get(mouseX, mouseY);
  if (id > -1) {
    for (int i=0; i<characters.size(); i++) {
      if (i == id) {
        characters.get(id).changeToDefaultColor();
      }
    }
  }
  
}
*/

void oscEvent(OscMessage theOscMessage) {
  // TODO(sanjeet): Figure out with Friedrich how to parse the message and stuff
  if(theOscMessage.isPlugged()==false) {
  }
}

void customize(DropdownList ddl) {
  ddl.setBackgroundColor(color(190));
  ddl.setItemHeight(20);
  ddl.setBarHeight(15);
  ddl.captionLabel().set("pulldown");
  ddl.captionLabel().style().marginTop = 3;
  ddl.captionLabel().style().marginLeft = 3;
  ddl.valueLabel().style().marginTop = 3;
//  for(int i=0;i<2;i++) {
    ddl.addItem("180 deg",0);
    ddl.addItem("30 deg",1);
//  }
  ddl.setColorBackground(color(60));
  ddl.setColorActive(color(255,128));
}

void controlEvent(ControlEvent theEvent) {
  // PulldownMenu is if type ControlGroup.
  // A controlEvent will be triggered from within the ControlGroup.
  // therefore you need to check the originator of the Event with
  // if (theEvent.isGroup())
  // to avoid an error message from controlP5.
  if (theEvent.isGroup()){
    if (theEvent.group().name() == "ruleChoiceList") {
  //    println(theEvent.group().value()+" from "+theEvent.group());
      selectedRule = int(theEvent.group().value());
      //has to be here for the controlp5 library
    }
  } else if(theEvent.isController()) {
//    println(theEvent.controller().value()+" from "+theEvent.controller());
  }
  
  
//  switch(theEvent.controller().id()) {
//    case(1):
//    myColorRect = (int)(theEvent.controller().value());
//    break;
//    case(2):
//    myColorBackground = (int)(theEvent.controller().value());
//    break;
//    case(3):
//    println(theEvent.controller().stringValue());
//    break;  
//  }
}
